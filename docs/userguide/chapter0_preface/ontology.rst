Ontology
========

In the 1999 movie *The Matrix*, Keanu Reeves' character is having a rough day. He needs to master every martial art in just a few hours. But he's in luck. In the future, humans can download knowledge from computers directly into their brains. After a few swift clicks, Keanu turns towards the camera and dramatically says, `"I know Kung Fu!" <https://youtu.be/OrzgxUhnYjY?si=lpgV8uk4jBrx1lFD&t=70>`__.

Keanu was saved because someone had encoded all the world's **knowledge** about Kung Fu into a **meaningful language** that machines and humans can understand. *That's an ontology*. Put another way, an ontology is a formal representation of knowledge, expressed as a conceptual network that conveys meaning in a way that both humans and machines can process.

Far from being a far-out science fiction concept, ontologies form the backbone of many tools we use every day. They are foundational to the modern World Wide Web, social media networks, and media streaming platforms. Ontologies are immensely powerful tools for sharing knowledge, linking resources, and assigning meaning to data.

Background
----------

The roots of modern ontologies trace back to ancient Greece. Ontology, as a branch of metaphysics, deals with the nature of being. These philosophical origins are still evident in the way we conceptualize and structure knowledge in modern ontologies. You can explore more about the philosophical aspects of ontology here. 

In information science, ontologies were reinvented in the mid-20th century to bridge the gap between how humans and computers process information. For humans, information is understood as a set of concepts with meaningful, logically consistent relationships. For computers, however, information is represented as binary code: a sequence of ones and zeros.

.. admonition:: Thought Experiment: The Robot at the Salad Bar

   Imagine you have built a robot to do your bidding. You ask it to go to a restaurant, make a salad at the salad bar, and bring it back to you. What information does the robot need to know to accomplish that task?

   It needs to know...

   - where the restaurant is and how to get there
   - the recipe for a salad and how to select the ingredients from the salad bar
   - that a salad comes in a bowl and is proportioned as a meal for one or more people
   - etc.

   Even this seemingly simple task requires a vast amount of information across multiple domains. However, the challenge isn’t just the volume of information—it’s also the need for this information to be linked together in a logically consistent way. This linkage allows the robot to reason about aspects of the task that are not explicitly stated.

To get over this barrier, researchers developed ontologies in the form of network graphs. These graphs link concepts using relationships in node-edge-node statements called *triples*. The concepts within the graph can then be mapped to computer datasets, effectively assigning meaning to the data and enabling machines to process and reason about it.

The next major step came in 1989 from a quiet corner of Switzerland. A 34-year-old researcher at CERN named Tim Berners-Lee was trying to develop a way to manage the vast amount of data generated by the nuclear research facility. He proposed a knowledge management system using hypertext to link documents and datasets. He called this system *The Mesh*, but within a few short years, it would be known by another name: *The World Wide Web*.

After the invention of the World Wide Web, the volume of information available to humans and computers grew exponentially. It quickly became evident that merely linking resources with hypertext was not sufficient to navigate the wilderness of data. The answer was *The Semantic Web*, an extension of the World Wide Web that uses ontologies and other semantic tools to describe the meaning of data and the nature of its connections. 

To build the Semantic Web, the World Wide Web Consortium (W3C) created a core technology stack expressed as a system of standards, including the Resource Description Framework (RDF) and the Web Ontology Language (OWL). RDF provides a basic model for representing data as triples (subject-predicate-object) in a graph structure. OWL extends RDF and is designed to represent rich and complex knowledge about things, groups of things, and relationships between them. These Semantic Web standards - among others - are the foundation of much of today’s ontology development.

Semantic Reasoning
------------------

One of the most powerful features of ontologies is their ability to enable reasoning. Reasoning allows machines to infer new knowledge from existing data. For example, if an ontology defines that all salads are food and Caesar salads are a type of salad, a reasoning system can conclude that Caesar salad is food—even if this specific relationship is not explicitly stated in the data.

This inferencing capability is crucial for solving complex problems and answering questions that go beyond surface-level information. Reasoning in ontologies is supported by formal logic and rules embedded within frameworks like OWL. These rules allow machines to:

- **Classify Data:** Automatically categorize new items based on their properties and relationships.

- **Check Consistency:** Ensure that data does not contain logical contradictions (e.g., an object cannot simultaneously be defined as "hot" and "cold").

- **Discover Relationships:** Identify hidden connections between concepts, enhancing data integration and discovery.

For instance, reasoning systems are used in healthcare to determine potential drug interactions based on patient data and medical ontologies. Similarly, in battery science, reasoning can help identify optimal materials by linking experimental results with material properties and performance metrics.

.. admonition:: Thought Experiment: The One-Armed Person

   Imagine we want to describe humans in an ontology. We might include some relationships like:

   - A human is a mammal
   - A human has one brain
   - A human has two arms
   - A man is a human
   - A woman is human
   - etc. 

   We might then create an individual called *Jesper* and make the statement that 'Jesper is a man'. Reasoning according to the knowledge in the ontology will return that because 'Jesper is a man' and 'a man is a human', then it follows that 'Jesper is a human'.

   But then Jesper loses an arm in some terrible accident. We append the statement 'Jesper has one arm'. Reasoning again will create a logical inconsistency because if 'Jesper has one arm' and 'a human as two arms', then it follows that Jesper cannot be a human. 

   This demonstrates how tricky it can be to maintain internal logical consistency, especially for complex ontologies, and how important it is to support correct reasoning and inferrence. 

By enabling machines to "think" beyond the explicit data provided, reasoning transforms ontologies into dynamic tools for problem-solving and decision-making.

Semantic Querying
-----------------

One of the most transformative applications of ontologies is their support for semantic querying. Unlike traditional keyword-based searches, semantic queries leverage the structured knowledge within ontologies to deliver precise and meaningful results. By understanding the relationships between concepts, machines can interpret queries in a way that mimics human reasoning. 

For example, if an ontology knows that "Golden Retriever" is a type of "dog," and a "dog" is an "animal", then a query for "animal" can return results that include Golden Retrievers, even if they were not explicitly mentioned.

Semantic querying is powered by languages such as SPARQL, a query language designed for RDF-based data. SPARQL allows users to retrieve and manipulate structured data by specifying patterns to match within the ontology’s graph. For example, a SPARQL allows users to transform natural human queries like, "Which restaurants serve vegetarian salads?" or "What materials are compatible with a specific battery type?" into a graph pattern to retrieve compatible answers. The ontology’s structure enables the system to traverse relationships and return accurate answers based on the data.

This capability is invaluable in fields like healthcare, where semantic queries can identify drug interactions or link patient symptoms to potential diagnoses. Similarly, in environmental research, semantic querying can connect datasets on climate patterns, biodiversity, and conservation efforts. By enabling machines to "understand" data, ontologies transform how we access and utilize information, making semantic querying a cornerstone of modern knowledge systems.

Modularity in Ontologies
------------------------

Ontologies are not monolithic structures; instead, they are often modular and designed to be extended. This modularity ensures flexibility, scalability, and reusability, allowing ontologies to be tailored for specific domains and applications while remaining consistent with broader frameworks.

.. admonition:: **The Benefits of Modularity**

    **Scalability:** Modular ontologies can grow incrementally by adding new modules without overhauling the entire system.

    **Reusability:** Common frameworks and domain ontologies can be reused across multiple applications, reducing duplication of effort.

    **Interoperability:** Modular design ensures compatibility between different ontologies, enabling seamless data integration and exchange.

The modular nature of ontologies reflects their purpose: to provide a structured yet flexible way to represent and share knowledge, making them indispensable tools for modern information systems.

Top-Level Ontologies
~~~~~~~~~~~~~~~~~~~~

At the source of many ontologies are top-level frameworks, often called upper ontologies. These define the most general concepts and relationships that apply across multiple domains. Top-level ontology frameworks establish the rules and shared vocabulary for creating domain-specific ontologies. They provide the "grammar" for more specialized knowledge representations and promote the re-use of existing concepts within their internal systems. Some notable exmaples of top-level ontologies include Basic Formal Ontology (BFO), Descriptive Ontology for Linguistic and Cognitive Engineering (DOLCE), and the Elementary Multiperspective Materials Ontology (EMMO). 

.. admonition:: *Some Common Top-Level Ontologies*

    BFO is a widely used top-level ontology in science and healthcare. It provides a framework for domain-specific extensions by focusing on general concepts such as objects, processes, and their interrelations. It emphasizes simplicity and consistency, making it a reliable backbone for more specialized ontologies.

    DOLCE is designed to represent common human experiences and conceptualizations. It captures everyday knowledge and cognitive structures. Its focus on common sense reasoning makes it particularly valuable for applications in linguistics, cognitive science, and AI.

    EMMO is specialized ontology developed for materials science and engineering. It integrates perspectives from physics, chemistry, and engineering to create a cohesive framework for modeling materials and their properties. It supports data interoperability and advanced simulations across disciplines.

Domain Ontologies
~~~~~~~~~~~~~~~~~~~~

Domain ontologies take the foundational concepts provided by top-level frameworks and expand them to cover knowledge specific to particular fields. For instance, the Gene Ontology (GO) delves into the intricacies of biological processes, cellular components, and molecular functions, offering a structured way to describe the complexity of life at a molecular level. Similarly, the Battery Ontology focuses on standardizing the representation of materials, components, and processes involved in battery research. By building on the shared principles of top-level ontologies, domain ontologies create a consistent and interoperable framework, enabling seamless integration of data across diverse fields.

Application Ontologies
~~~~~~~~~~~~~~~~~~~~~~

Application ontologies extend general and domain-specific knowledge to address specialized needs. For example, a healthcare ontology might focus on patient management by detailing intake processes, diagnostic tools, and treatment plans, tailoring it to hospital operations. Similarly, an agricultural ontology could describe crop cycles, soil management, and pest control practices to meet farming requirements. These extensions achieve a balance between addressing unique needs and staying compatible with broader frameworks.

Knowledge Graphs
~~~~~~~~~~~~~~~~

Knowledge graphs are a practical implementation of ontologies that represent specific instances of data as a dynamic network of interconnected entities and relationships. While ontologies focus on defining general concepts and their relationships, knowledge graphs concentrate on specific instances or individuals, connecting them to form a rich and navigable web of knowledge.

Powered by ontologies, knowledge graphs enhance integration, discovery, and reasoning across specific data instances. They are widely used in search engines (e.g., Google Knowledge Graph), recommendation systems, and intelligent assistants, providing context-aware results that mimic human-like understanding of data.

Fundamentals
------------

Ontologies are built on a few simple foundational components that can be combined to express knowledge. These include:
- Identifiers
- Classes
- Properties
- Triples

These components each build upon eachother to create an ontological framework, and we will introduce them one-by-one.

Identifiers
~~~~~~~~~~~
If an ontology is a language, then its identifiers are like the words. Identifiers are unique, persistent, and (ideally) resolvable strings that are used to identify some concept. They enable humans and machines to uniquely reference and access information about entities, concepts, and relationships.

Identifiers serve as the "name tags" for entities in an ontology. Without identifiers, there would be no way to distinguish one concept from another, particularly when integrating information across multiple datasets or domains. A good identifier ensures clarity, consistency, and interoperability.

.. admonition:: Thought Experiment: Who says the Taj Mahal is in India?

   One day you're having a chat with your friend and mention:

   **You**: "I'm in New York City, and I can't wait to see Taj Mahal later!"
   **Friend**: "New York City? You've got a long way to go...the Taj Mahal is in India!"
   **You**: "No, not that Taj Mahal...the other one! Here's a link... `https://en.wikipedia.org/wiki/Taj_Mahal_(musician) <https://en.wikipedia.org/wiki/Taj_Mahal_(musician)>`__"
   **Friend**: "Ok! I thought you meant the building `https://en.wikipedia.org/wiki/Taj_Mahal <https://en.wikipedia.org/wiki/Taj_Mahal>`__ Have fun!"

   You and your friend used identifiers (in this case URLs) to clear up a misunderstanding about the meaning of the term "Taj Mahal". Encoded into the URL is an explicit disambiguation about the term, i.e. :code:`Taj_Mahal_(musician)` v. :code:`Taj_Mahal`, but clicking on the link also takes you to an article with much more information and context about those particular things. 

   Ontologies use identifiers in the same way. They are unique identifiers that describe concepts and point to places where you can get more information about them, which can be accessed by people and machines.  

Types of Identifiers
^^^^^^^^^^^^^^^^^^^^

Uniform Resource Identifier (URI)
"""""""""""""""""""""""""""""""""
There are a few ways to construct identifiers in an ontology. The basic type of identifier is called a **Uniform Resource Identifier (URI)**. A URI is a globally unique identifier used to reference a resource. It often takes the form of a web address (URL), but it can also refer to non-resolvable identifiers. For example, a resolvable identifier may take the form :code:`https://example.com/ontology#Person`, while a non-resolveable identifer could be structured as :code:`urn:isbn:0451450523`. Resolvable identifiers are used when creating public-facing ontologies designed for interoperability and linked open data. Non-resolvable identifiers are used more for closed systems or internal workflows.

Internationalized Resource Identifier (IRI)
"""""""""""""""""""""""""""""""""""""""""""
While URIs are limited to using an allowed set of US-ASCII characters, IRIs may additionally contain most characters from the Universal Character Set (Unicode/ISO 10646), including Chinese, Japanese, Korean, and Cyrillic characters. This makes them more inclusive for international use.

Blank Nodes
"""""""""""
Sometimes resources are defined without stating an explicit identifier. Although this is not the best practice for ontologies, it can occur when creating instances of linked data, e.g. in JSON-LD files, where a globally unique name is not strictly necessary. To deal with this, instead of creating a URI or IRI, RDF interpreters can create so-called blank nodes.

A **blank node** is an unnamed resource in an RDF graph that does not have a persistent, globally unique identifier. Instead, it is assigned an internal system-generated identifier (e.g., _bnode123) that is only meaningful within the scope of the specific dataset or query. Blank nodes are useful when an entity needs to exist in the data structure but does not require an explicit name.

Structure of Identifiers
^^^^^^^^^^^^^^^^^^^^^^^^
Identifiers are usually structured with three parts: a namespace, a delimiter, and a term name. These take the structure, :code:`<namespace><delimiter><term_name>`. 

A **namespace** groups related identifiers under a common domain. For example, the namespace for core EMMO terms is: :code:`https://w3id.org/emmo`. 

**Delimiters** are typically either a slash :code:`/` or a hashtag :code:`#`. A slash (:code:`/`) indicates a hierarchical structure, where additional subpaths may exist beyond the term. This is useful when identifiers represent distinct resources that might have further subdivisions. A hashtag (:code:`#`) is used when the term is self-contained and does not require further hierarchy. It is often used in ontologies where all terms are defined within a single document or namespace.

The combination of namespaces and delimiters can often become long and cumbersome to write. That's why a **prefix** is often used to simplify the notation of identifiers. A prefix is like a variable that stands in for the namespace and delimiter combination. For example, identifiers in the RDF vocabulary take the form: :code:`http://www.w3.org/1999/02/22-rdf-syntax-ns#type`. This can be difficult for people to read and write. So a prefix is defined like :code:`@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .`, which allows the identifier to be written more concisely as :code:`rdf:type`.

The **term name** identifies the term within the namespace. It can be a human-readable name or a unique alpha-numeric identifier like a UUID. *Human-readable names* are easy to understand and remember, making ontologies more accessible for people. But they can face challenges when the same name can be used to describe two different resources (e.g. like the Taj Mahal example). An example of an identifier with a human-readable term name is: :code:`https://schema.org/Person`

*UUIDs* ensure absolute uniqueness but are not human-readable. UUIDs are useful when term names may not be stable or where name conflicts need to be avoided across distributed systems. An example of an identifier with a UUID term name is: :code:`https://w3id.org/emmo#EMMO_ed4af7ae_63a2_497e_bb88_2309619ea405` 

Permanent URLs (PURLs)
""""""""""""""""""""""
Identifiers should be persistent and not change over long-term use. This can create challenges for maintanence of ontology resources, if maintainers change organizations or funding for certain domain names runs out. It sometimes becomes necessary to change the domain where ontology resources are hosted. Permanent URL (PURL) services can be help deal with this challenge. 

PURLs are design to offer permanent, persistent identifiers that can be modified to redirect requests to different domains. This allows the structure of the identifier to remain the same, even if the place where the information is hosted changes. There are a few common PURL services. Two of the most common are `w3id.org <https://w3id.org/>`__ and `purl.org <https://purl.org/>`__. EMMO uses the w3id service.  

Classes, Properties, and Triples
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Like any language, an ontology consists of different types of words that define concepts and relationships. **Classes** function like *nouns*, representing people, places, things, and ideas. While classes typically act like common nouns, describing general categories of things (e.g., :code:`schema:Person` for people), **individuals** act more like proper nouns, identifying specific instances of those classes (e.g., :code:`ex:MarieCurie` as an instance of :code:`schema:Person`).

**Properties** function like *verbs*, linking classes and individuals by defining relationships or attributes. These relationships and attributes form **triples**, which are the basic building blocks of RDF-based ontologies. A triple consists of three components: a **subject**, a **predicate**, and an **object**, analogous to a simple sentence structure.

For example, we can define the class **CreativeWork** (:code:`schema:CreativeWork`) and a subclass **Book** (:code:`schema:Book`). To indicate that a book is a type of creative work, we use the property :code:`rdf:type`, which expresses an "is a" relationship. This can be written as:

:code:`schema:Book rdf:type schema:CreativeWork .`

In natural language, this translates to:
*"A book is a creative work."*

In this triple:
- **Subject**: :code:`schema:Book` (the entity being described)
- **Predicate**: :code:`rdf:type` (the relationship)
- **Object**: :code:`schema:CreativeWork` (the entity that the subject is linked to)

Predicates are always **properties**, while subjects and objects can be **classes, individuals, or literal values**.

Properties
""""""""""""
Properties in ontologies define relationships between entities and can specify **constraints** on how they are used. Every property has:
- **Domain**: The class or set of classes that can appear as the subject.
- **Range**: The class or set of classes that can appear as the object.

For example, consider the property :code:`ex:hasAuthor`, where:
- **Domain**: :code:`schema:CreativeWork` (a creative work can have an author)
- **Range**: :code:`schema:Person` (the author must be a person)

A valid use of this property:
:code:`ex:MyBook ex:hasAuthor ex:Alice .`

An **invalid** use of this property:
:code:`ex:Alice ex:hasAuthor ex:MyBook .`

To allow statements in the reverse direction, ontologies sometimes define **inverse properties**. For instance, an inverse property of :code:`ex:hasAuthor` could be :code:`ex:isAuthorOf`, allowing:

:code:`ex:Alice ex:isAuthorOf ex:MyBook .`

RDF Ontologies define different types of properties based on their function:

1. **Object Properties**: Connect two classes or individuals.
   Example:
   :code:`ex:MyBook ex:hasAuthor ex:Alice .`
   *(This states that "MyBook" was written by Alice.)*

2. **Annotation Properties**: Provide metadata such as labels, descriptions, or documentation.
   Example:
   :code:`schema:Book rdfs:comment "A written work, typically bound and published." .`
   *(This provides a human-readable description of a book.)*

3. **Data Properties**: Link a class or individual to literal values (e.g., numbers, strings, or dates).
   Example:
   :code:`ex:Alice schema:birthDate "1965-07-20"^^xsd:date .`
   *(This states that Alice was born on July 20, 1965.)*

Together, **classes, properties, and triples** form the foundation of an ontology, structuring knowledge in a way that is both human-readable and machine-processable.
